一、虚拟机类加载机制：
    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
二、类加载过程：
    类从被加载到虚拟机内存中开始，到卸载出内存为止，他的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析
    （Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。
    加载 --->  { 验证 ---> 准备 ---> 解析}连接 --->  初始化 ---> 使用 ---> 卸载。
    1. 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会出触发类的初始化而不会触发子类的初始化。
       （父类和子类中均有静态代码块，但只有父类中有静态字段，且其他类调用了这个静态字段）
    2. 数组在编译时也不会触发类的初始化。
    3. 调用静态常量也不会触发类的初始化。
    
    （1）加载
         在加载阶段，虚拟机需要完成以下3件事情：
         1. 通过一个类的全限定名来获取此类的二进制字节流。
         2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
         3. 在内存中生成一个这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
    （2）验证
         验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证
         1. 文件格式验证：
            第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理；
            该验证阶段的主要目的是保证输入的字符流能正确地解析并存储在方法区，格式上符合描述一个Java类型信息的要求；
            这个阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入方法区中进行存储。
         2. 元数据验证：
            第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
         3. 字节码验证********重点
            第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；
            在第二阶段对元数据信息中的数据类型昨晚校验后，这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
         4. 符号引用验证：
            最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候；
            符号引用验证的目的是确保动作能正常运行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类。
    （3）准备
         准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
         类变量为被static修饰的变量。    变量被设置初始值，而不是代码中写的值。
    （4）解析
         解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。（符号引用以一组符号来描述所引用的目标；直接引用可以是直接指向目标的指针、相对偏
            移量或是一个能间接定位到目标的句柄。
         解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池CONSTANT_CLASS_info、
            CONSTANT_Fiedref_info、CONSTANT_Methodref.info、CONSTANT_InterfaceMethonref_info、CONSTANT_MethodType_info、
            CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType.info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量类型
         1. 类或接口的解析；2. 字段解析； 3. 类方法解析；4. 接口方法解析。
    （5）初始化
         类初始化阶段是类加载过程的最后一步。
         变量在初始化阶才根据程序员设定的值去初始化变量。
         1. 类和类加载器
            比较两个类是否“相等”，必须被相同的类加载器加载才有意义；
         2. 双亲委派模型
                                                        启动类加载器
                                                        扩展类加载器
                                                      应用程序类加载器
                                               自定义类加载器    自定义类加载器
           图中展示的类加载其之间的层次关系，称为类加载其的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类
               加载器。这里的父类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载的代码。
           双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个
               层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器，当有父类加载器反馈自己无法完成这个加载请求（它的搜索
               范围中没有找到所需的类）时，子加载才会尝试自己去加载。
           使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。
           双亲委派模型对于保证Java程序的稳定运行很重要，因为只有同一个类加载器加载的类才可能“相等”。
           例如类java.lang.Object,它存放在rt.jart之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.因此
               Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.如果用户编写了一个称为
               “java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用
               程序也将会一片混乱.
三、深入理解
    1、在ClassLoader的方法中，表示类名称的name参数的值是类的二进制名称。需要注意的是内部类的表示，如com.example/Sample$1和
       com.example.Sample$Inner等表示方式。
    2、虚拟机如何判定两个Java类是相同的？
       Java虚拟机不仅看类的全名是否相同，还要看加载此类的泪加载器是否一样。
    3、在Java虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载其启动类的家在过程并不重要，重要的是最终定义这个类的加载器。
       两种类加载其的关联之处在于：一个类的定义加载器是它引用的其他类的初始化加载器。如类com.example.Outer引用了类com.example.Inner，则由类
       com.example.Outer的定义加载器负责启动类com.example.Inner的加载过程。
       方法loadClass()抛出的异常时java.lang.ClassNotFoundException异常；方法defineClass()抛出的是java.lang.NoClassDefFoundError异常。
    4、Class.forName
       Class.forName是一个静态方法，同样可以用于加载类。
       Class.forName的一个很常见的用法是在加载数据库驱动的时候。如Class.forName(""org.apache.derby.jdbc.EmbeddedDriver").newInstance()用来加载
             Apache Derby 数据库的驱动。
    5、自己的类加载器
       一般来说，自己开发的类加载器只需要覆写findClass(String name)方法即可。java.lang.ClassLoader类的方法loadClass()封装了前面提到的代理模式的
           实现。该方法会首先调用findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的loadClass()方法来尝试加载；
           如果父类加载器无法加载该类的话，就调用findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不
           要覆写loadClass()方法，而是覆写findClass()方法。
    6、类加载器与Web容器
       以Apache Tomcat来说，每个Web应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给
          父类加载器。这与一般类加载器的顺序是相反的。这是Java Servlet规范中的推荐做法，其目的是使得Web应用自己的类的优先级高于Web容器提供的类。这
          中代理模式有一个例外：Java核心库的类是不在查找范围之内的。这也是为了保证Java核心库的类形安全。
       绝大多数情况下，Web应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的规则：
          （1）每个Web应用自己的Java类文件和使用的库的jar包，分别放在WEB-INF/classes和WEB-INF/lib目录下面。
          （2）多个应用共享的Java类文件和jar包，分别放在Web容器指定的由所有Web应用共享的目录下面。
          （3）当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文加载器是否正确。
              

---------------------------------------------------------------------------------------------------------------------------------------


类加载机制

    Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。

    类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载（Loading）、验证（Verification）、准备（Preparation）、
        解析（Resolution）、初始化（Initialization）、使用（using）、和卸载（Unloading）七个阶段。其中验证、准备和解析三个部分统称为连接（Linking），这七个阶段的发生顺序如下图所示：

    如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况
      下可以在初始化阶段后再开始。

    类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。

一、类加载的时机

主动引用：一个类被主动引用之后会触发初始化过程（加载，验证，准备需再此之前开始）

    1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码
       场景是：使用new关键字实例化对象时、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时、以及调用一个类的静态方法的时候。

    2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

    3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要触发父类的初始化。

    4）当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的类），虚拟机会先初始化这个类。

    5）当使用jdk7+的动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法
       句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发器 初始化。

被动引用：一个类如果是被动引用的话，该类不会触发初始化过程

    1）通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义该字段的类才会被初始化，因此当我们通过子类来引用父类中定义的静态字
       段时，只会触发父类的初始化，而不会触发子类的初始化。

    2）通过数组定义来引用类，不会触发此类的初始化。

    3）常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。


二、类加载过程

1、加载

在加载阶段，虚拟机需要完成以下三件事情：

    1.通过一个类的权限定名称来获取定义此类的二进制字节流。

    2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

    3.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

    相对于类加载过程的其他阶段，加载阶段是开发期相对来说可控性比较强，该阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，
        开发人员可以通过定义自己的类加载器去控制字节流的获取方式。

2、验证

    验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，
        但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。

     1）文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储
        于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。

     2）元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。

    3）字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。

    4）符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的
       信息（常量池中的各种符号引用）进行匹配性的校验。

3、准备

     准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

     注：
     1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

     2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

4、解析

    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

    符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用
        的目标并不一定已经在内存中。

    直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的,
        同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

    1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。

    2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系
       从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。

    3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。
   
    4、接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。

5、初始化

    类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导
        和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

     初始化阶段是执行类构造器<clinit>()方法的过程。

    1）<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现
       的顺序所决定。

    2）<clinit>()方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完
       毕，因此在虚拟机中第一个执行的<clinit>()方法的类一定是java.lang.Object。

    3）由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

    4）<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

    5）接口中可能会有变量赋值操作，因此接口也会生成<clinit>()方法。但是接口与类不同，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。
       只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的<clinit>()方法。

    6）虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的
       <clinit>()方法，其它线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。

三、双亲委派模型

JVM预定义的三种类型类加载器：

     1）启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将 <Java_Runtime_Home>/lib下面的类库加载到内存中（比如rt.jar）。由于引导类
        加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

     2）标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将
        < Java_Runtime_Home >/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。

     3）系统（System）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的
        类库加载到内存中。开发者可以直接使用系统类加载器。

双亲委派机制描述：
     某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器
         无法完成此加载任务时，才自己去加载。
          
