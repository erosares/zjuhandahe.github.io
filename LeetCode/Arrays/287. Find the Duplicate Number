Description:
    Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, 
        find the duplicate one.
Note:
    1. You must not modify the array (assume the array is read only).
    2. You must use only constant, O(1) extra space.
    3. Your runtime complexity should be less than O(n2).
    4. There is only one duplicate number in the array, but it could be repeated more than once.

---------------------------------------------------------------------------------------------------------------------------------------MY----------------------------------------------------------------------------------------------------------------------------
Analysis:
    方法一：标志位方法，设定长度为n的数组flags作为标志，遍历nums，在对应位置的flags[nums[i]-1]++，最后统计flags[j]>1的那个位置，则返回j+1。
    方法二：二分查找法，假设原始数组[1,2,3,4,5,6,X,7,8,10]，其中X为多出的一个数字；
                      那么在该数组中小于等于mid = 5的个数小于等于5的时候，则重复的数就应该在数字大的那部分；
                      否则，重复的数字就应该在数字小的那部分。
    方法三：
Solutions:
    解法一：
        public static int findDuplicate(int[] nums) {
            if (nums == null || nums.length == 0) return 0;
            int n = nums.length;
            int[] flags = new int[n - 1];
            for (int i = 0; i < n; i++) {
                flags[nums[i] - 1]++;
            }
            for (int i = 0; i < n - 1; i++) {
                if (flags[i] > 1) return i + 1;
            }
            return 0;
        }
    解法二：
        public static int findDuplicate2(int[] nums) {
            int low = 1;
            int high = nums.length - 1;
            while (low < high) {
                int mid = (low + high) / 2;
                if (count(nums, mid) <= mid) {
                    ow = mid + 1;
               } else {
                   high = mid;
                }
            }
            return low;
        }
        
        private static int count(int[] nums, int mid) {//count less than mid numbers
            int count = 0;
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] <= mid) count++;
            }
            return count;
        }
    解法三：
