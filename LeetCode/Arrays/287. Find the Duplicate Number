Description:
    Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, 
        find the duplicate one.
Note:
    1. You must not modify the array (assume the array is read only).
    2. You must use only constant, O(1) extra space.
    3. Your runtime complexity should be less than O(n2).
    4. There is only one duplicate number in the array, but it could be repeated more than once.

---------------------------------------------------------------------------------------------------------------------------------------MY----------------------------------------------------------------------------------------------------------------------------
Analysis:
    方法一：标志位方法，设定长度为n的数组flags作为标志，遍历nums，在对应位置的flags[nums[i]-1]++，最后统计flags[j]>1的那个位置，则返回j+1。
    方法二：二分查找法，这里比较的是mid，而不是nums[mid]。
                      假设原始数组[1,2,3,4,5,6,X,7,8,10]，其中X为多出的一个数字；
                      那么在该数组中小于等于mid = 5的个数小于等于5的时候，则重复的数就应该在数字大的那部分；
                      否则，重复的数字就应该在数字小的那部分。
    方法三：
Solutions:
    解法一：
        public static int findDuplicate(int[] nums) {
            if (nums == null || nums.length == 0) return 0;
            int n = nums.length;
            int[] flags = new int[n - 1];
            for (int i = 0; i < n; i++) {
                flags[nums[i] - 1]++;
            }
            for (int i = 0; i < n - 1; i++) {
                if (flags[i] > 1) return i + 1;
            }
            return 0;
        }
    解法二：
       public static int findDuplicate(int[] nums) {
        int low = 0, high = nums.length - 1;
        while(low <= high){
            // 找到中间那个数
            int mid = low + (high - low) / 2;
            int cnt = 0;
            // 计算总数组中有多少个数小于等于中间数
            for(int i = 0; i < nums.length; i++){
                if(nums[i] <= mid){
                    cnt++;
                }
            }
            // 如果小于等于中间数的数量大于中间数，说明前半部分必有重复
            if(cnt > mid){
                high = mid - 1;
                // 否则后半部分必有重复
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
    解法三：
