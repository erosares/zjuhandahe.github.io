Description:
    Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
    Your algorithm's runtime complexity must be in the order of O(log n).
    If the target is not found in the array, return [-1, -1].
Example:
    Given [5, 7, 7, 8, 8, 10] and target value 8,
    return [3, 4].

-----------------------------------------------------MY-----------------------------------------------------------------
Analysis:
    第一种：运用两个指针，left和right，从两头向中间匹配，直到nums[left]==tragt和nums[right]==target，其中需要注意多种特殊情况。
    第二种：
Solutions:
    第一种：
        public int[] searchRange(int[] nums, int target) {
		      int left = 0;
		      int right = nums.length - 1;
		      if (nums == null || nums.length == 0 || nums[0] > target
				      || nums[nums.length - 1] < target)
			      return new int[] { -1, -1 };
		      if (nums.length == 1) {
			       if (nums[0] == target)
				      return new int[] { 0, 0 };
			       return new int[] { -1, -1 };
		      }
		      while (right > left && (nums[left] != target || nums[right] != target)) {
			      if (nums[left] != target) {
				      left++;
			      }
			      if (nums[right] != target) {
				      right--;
			      }
		      }
		      if (nums[left] == target && nums[right] == target) {
			      return new int[] { left, right };
		      }
		      if (left >= right) {
			      return new int[] { -1, -1 };
		      }
		      return new int[] { left, right };
	      }
    第二种：
